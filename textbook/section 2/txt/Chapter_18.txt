# Chapter 18 Service-oriented software engineering:
## 18.1 Service-oriented architecture
## 18.2 RESTful services
## 18.3 Service engineering
## 18.4 Service composition

---

### 18.1 Service-oriented architecture:

Service-oriented architecture (SOA) is an architectural style based on the idea that executable services can be included in applications. Services have well-defined, published interfaces, and applications can choose whether or not these are appropriate. An important idea underlying SOA is that the same service may be available from different providers and that applications could make a runtime decision of which service provider to use.  †Newcomer, E. and Lomow, G. (2005). Understanding SOA with Web Services. Boston: Addison-Wesley.    18.1 ■ Service-oriented architecture 525  Service  registry  Find  Publish  Service  Service  requestor  Service  Figure 18.2 Service—  provider  Bind (SOAP)  oriented architecture  (WSDL)  XML technologies (XML, XSD, XSLT, ....)  Support (WS-Security, WS-Addressing, ...)  Process (WS-BPEL)  Service definition (UDDI, WSDL)  Messaging (SOAP)  Figure 18.3 Web  Transport (HTTP, HTTPS, SMTP, ...)  service standards  Figure 18.2 illustrates the structure of a service-oriented architecture. Service providers design and implement services and specify the interface to these services. They also publish information about these services in an accessible registry. Service requestors (sometimes called service clients) who wish to make use of a service discover the specification of that service and locate the service provider. They can then bind their application to that specific service and communicate with it, using standard service protocols.  The development and use of internationally agreed standards is fundamental to  SOA. As a result, service-oriented architectures have not suffered from the incompatibilities that normally arise with technical innovations, where different suppliers  maintain their proprietary version of the technology. Figure 18.3 shows the stack of key standards that have been established to support web services.  Web service protocols cover all aspects of service-oriented architectures, from the  basic mechanisms for service information exchange (SOAP) to programming language  standards (WS-BPEL). These standards are all based on XML, a human and machine-readable notation that allows the definition of structured data where text is tagged with a meaningful identifier. XML has a range of supporting technologies, such as XSD for schema definition, which are used to extend and manipulate XML descriptions. Erl (Erl 2004) provides a good summary of XML technologies and their role in web services.  Briefly, the fundamental standards for service-oriented architectures are:  1. SOAP This is a message interchange standard that supports communication between services. It defines the essential and optional components of messages  526 Chapter 18 ■ Service-oriented software engineering  passed between services. Services in a service-oriented architecture are sometimes called SOAP-based services.  2. WSDL The Web Service Description Language (WSDL) is a standard for service interface definition. It sets out how the service operations (operation names,  parameters, and their types) and service bindings should be defined.  3. WS-BPEL This is a standard for a workflow language that is used to define process programs involving several different services. I explain what process programs are in Section 18.3.  The UDDI (Universal Description, Discovery, and Integration) discovery standard  defines the components of a service specification intended to help potential users  discover the existence of a service. This standard was meant to allow companies to set up registries, with UDDI descriptions defining the services they offered. Some companies set up UDDI registries in the early years of the 21st century, but users preferred standard search engines to find services. All public UDDI registries have now closed.  The principal SOA standards are supported by a range of supporting standards  that focus on more specialized aspects of SOA. There are many supporting standards  because they are intended to support SOA in different types of enterprise application. Some examples of these standards include:  1. WS-Reliable Messaging, a standard for message exchange that ensures messages will be delivered once and once only.  2. WS-Security, a set of standards supporting web service security, including standards that specify the definition of security policies and standards that cover the  use of digital signatures.  3. WS-Addressing, which defines how address information should be represented in a SOAP message.  4. WS-Transactions, which defines how transactions across distributed services should be coordinated.  Web service standards are a huge topic, and I don’t have space to discuss them in  detail here. I recommend Erl’s books (Erl 2004, 2005) for an overview of these  standards. Their detailed descriptions are also available as public documents on the Web (W3C 2013).    18.1.1 Service components in an SOA  Message exchange, as I explained in Section 17.1, is an important mechanism for  coordinating actions in a distributed computing system. Services in a SOA communicate by exchanging messages, expressed in XML, and these messages are distributed using standard Internet transport protocols such as HTTP and TCP/IP.  A service defines what it needs from another service by setting out its requirements in a message, which is sent to that service. The receiving service parses the    18.1 ■ Service-oriented architecture 527  WSDL service definition  Intro  XML namespace declarations  Type declarations  Abstract interface  Interface declarations  Message declarations  Concrete  Figure 18.4  Binding declarations  implementation  Organization of a WSDL  Endpoint declarations  specification  message, carries out the computation, and, upon completion, sends a reply, as a message, to the requesting service. This service then parses the reply to extract the  required information. Unlike software components, services do not use remote  procedure or method calls to access functionality associated with other services.  When you intend to use a web service, you need to know where the service is located  (its Uniform Resource Identifier—URI) and the details of its interface. These details are provided in a service description that is written in an XML-based language called WSDL  (Web Service Description Language). The WSDL specification defines three aspects of  a Web service: what the service does, how it communicates, and where to find it:  1. The “what” part of a WSDL document, called an interface, specifies what operations the service supports and defines the format of the messages sent and  received by the service.  2. The “how” part of a WSDL document, called a binding, maps the abstract interface to a concrete set of protocols. The binding specifies the technical details of  how to communicate with a Web service.  3. The “where” part of a WSDL document describes the location of a specific Web  service implementation (its endpoint).  The WSDL conceptual model (Figure 18.4) shows the elements of a service  description. Each element is expressed in XML and may be provided in separate  files. These elements are:  1. An introductory part that usually defines the XML namespaces used and that  may include a documentation section providing additional information about  the service.  2. An optional description of the types used in the messages exchanged by the service.  3. A description of the service interface, that is, the operations that the service provides for other services or users.  4. A description of the input and output messages processed by the service.  5. A description of the binding used by the service, that is, the messaging protocol that will be used to send and receive messages. The default is SOAP, but other  528 Chapter 18 ■ Service-oriented software engineering  Define some of the types used. Assume that the namespace prefixes ’ws’ refers to  the namespace URI for XML schemas and the namespace prefix associated with this  definition is weathns.  <types>  <xs: schema targetNameSpace = “http://. . ./weathns”  xmlns: weathns = “http://. . ./weathns” >  <xs:element name = “PlaceAndDate” type = “pdrec” />  <xs:element name = “MaxMinTemp” type = “mmtrec” />  <xs:element name = “InDataFault” type = “errmess” />  <xs:complexType name = “pdrec”  <xs:sequence>  <xs:element name = “town” type = “xs:string”/>  <xs:element name = “country” type = “xs:string”/>  <xs:element name = “day” type = “xs:date” />  </xs:complexType>  Definitions of MaxMinType and InDataFault here  </schema>  </types>  Now define the interface and its operations. In this case, there is only a single  operation to return maximum and minimum temperatures  <interface name = “weatherInfo” >  <operation name = “getMaxMinTemps” pattern = “wsdlns: in-out”>  <input messageLabel = “In” element = “weathns: PlaceAndDate” />  <output messageLabel = “Out” element = “weathns:MaxMinTemp” />  <outfault messageLabel = “Out” element = “weathns:InDataFault” />  </operation>  </interface>  Figure 18.5 Part of a  bindings may also be specified. The binding sets out how the input and output  WSDL description for a  messages associated with the service should be packaged into a message, and  web service  specifies the communication protocols used. The binding may also specify how  supporting information, such as security credentials or transaction identifiers, is  included in messages to the service.  6. An endpoint specification that is the physical location of the service, expressed as a URI—the address of a resource that can be accessed over the Internet.  Figure 18.5 shows part of the interface for a simple service that, given a date and a place, specified as a town within a country, returns the maximum and minimum temperature recorded in that place on that date. The input message also specifies whether these temperatures are to be returned in degrees Celsius or degrees Fahrenheit.  XML-based service descriptions include definitions of XML namespaces. A namespace identifier may precede any identifier used in the XML description, making it possible to distinguish between identifiers with the same name that have been defined in different parts of an XML description. You don’t have to understand the details of namespaces to  18.2 ■ RESTful services 529  understand the examples here. You only need to know that names may be prefixed with a namespace identifier and that the namespace:name pair should be unique.  In Figure 18.5, the first part of the description shows part of the element and type definition that is used in the service specification. This defines the elements  PlaceAndDate, MaxMinTemp, and InDataFault. I have only included the specification  of PlaceAndDate, which you can think of as a record with three fields—town, country  and date. A similar approach would be used to define MaxMinTemp and InDataFault.  The second part of the description shows how the service interface is defined. In this example, the service weatherInfo has a single operation, although there are no restrictions on the number of operations that may be defined. The weatherInfo operation has an associated in-out pattern meaning that it takes one input message and generates one output message. The WSDL 2.0 specification allows for a number of message exchange patterns such as in-only, in-out, out-only, in-optional-out, and out-in. The input and output messages, which refer to the definitions made earlier in the types section, are then defined.  A service interface that is defined in WSDL is simply a description of the service  signature, that is, the operations and their parameters. It does not include any information about the semantics of the service or its nonfunctional characteristics, such as performance and dependability. If you plan to use the service, you have to work out what the service actually does and the meaning of the input and output messages.  You have to experiment to discover the service’s performance and dependability.  While meaningful names and documentation help with understanding the service  functionality, it is still possible to misunderstand what the service actually does.  XML-based service descriptions are long, detailed, and tedious to read. WSDL  specifications are not normally written by hand, and most of the information in a  specification is automatically generated.

### 18.2 RESTful services:

The initial developments of web services and service-oriented software engineering  were standards-based, with XML-based messages exchanged between services. This  is a general approach that allows for the development of complex services, dynamic  service binding, and control over quality of service and service dependability.  However, as services were developed, it emerged that most of these were single—  function services with relatively simple input and output interfaces. Service users  were not really interested in dynamic binding and the use of multiple service providers. They rarely use web service standards for quality of service, reliability, and so forth.  The problem is that web services standards are “heavyweight” standards that are  sometimes overly general and inefficient. Implementing these standards requires a considerable amount of processing to create, transmit, and interpret the associated XML  messages. This slows down communications between services, and, for high-throughput  systems, additional hardware may be required to deliver the quality of service required.  In response to this situation, an alternative “lightweight” approach to web service  architecture has been developed. This approach is based on the REST architectural  530 Chapter 18 ■ Service-oriented software engineering  CREATE  POST  URL  DELETE  Web-accessible  Resource R  READ  DELETE  GET  resource R  UPDATE  PUT  Figure 18.6 Resources  and actions  (a) General resource actions  (b) Web resources  style, where REST stands for Representational State Transfer (Fielding 2000). REST  is an architectural style based on transferring representations of resources from a  server to a client. It is the style that underlies the web as a whole and has been used as a much simpler method than SOAP/WSDL for implementing web service interfaces.  The fundamental element in a RESTful architecture is a resource. Essentially, a  resource is simply a data element such as a catalog and a medical record, or a document, such as this book chapter. In general, resources may have multiple representations; that is, they can exist in different formats. For example, this book chapter has three representations. These are a MS Word representation, which is used for editing, a PDF representation, which is used for web display, and a InDesign representation, which is used for publishing. The underlying logical resource made up of text and  images is the same in all of these representations.  In a RESTful architecture, everything is represented as a resource. Resources have  a unique identifier, which is their URL. Resources are a bit like objects, with four fundamental polymorphic operations associated with them, as shown in Figure 18.6(a):  1. Create—bring the resource into existence.  2. Read—return a representation of the resource.  3. Update—change the value of the resource.  4. Delete—make the resource inaccessible.  The Web is an example of a system that has a RESTful architecture. Web pages  are resources, and the unique identifier of a web page is its URL.  The web protocols http and https are based on four actions, namely, POST, GET,  PUT, and DELETE. These map onto the basic resource operations, as I have shown  in Figure 18.6(b):  1. POST is used to create a resource. It has associated data that defines the resource.  2. GET is used to read the value of a resource and return that to the requestor in the specified representation, such as XHTML, that can be rendered in a web browser.    18.2 ■ RESTful services 531  3. PUT is used to update the value of a resource.  4. DELETE is used to delete the resource.  All services, in some way, operate on data. For example, the service described in  Section 18.2 that returns the maximum and minimum temperatures for a location on  a given data uses a weather information database. SOAP-based services execute  actions on this database to return particular values from it. RESTful services  (Richardson and Ruby 2007) access the data directly.  When a RESTful approach is used, the data is exposed and is accessed using its  URL. RESTful services use http or https protocols, with the only allowed actions  being POST, GET, PUT, and DELETE. Therefore, the weather data for each place in  the database might be accessed using URLs such as:  http://weather-info-example.net/temperatures/boston  http://weather-info-example.net/temperatures/edinburgh  This would invoke the GET operation and return a list of maximum and minimum  temperatures. To request the temperatures for a specific date, a URL query can be used:  http://weather-info-example.net/temperatures/edinburgh?date=20140226  URL queries can also be used to disambiguate the request, given that there may  be several places in the world with the same name:  http://weather-info-example.net/temperatures/boston?date=20140226&country=  USA&state=“Mass”  An important difference between RESTful services and SOAP-based services is  that RESTful services are not exclusively XML-based. So, when a resource is  requested, created, or changed, the representation may be specified. This is important for RESTful services because representations such as JSON (Javascript Object  Notation), as well as XML, may be used. These can be processed more efficiently  than XML-based notations, thus reducing the overhead involved in a service call.  Therefore, the above request for maximum and minimum temperatures for Boston  may return the following information:  {  “place”: “Boston”,  “country “USA”,  “state”: “Mass”,  “date”: “26 Feb 2014”,  “units”: “Fahrenheit”,  “max temp”: 41,  “min temp”: 29  }  The response to a GET request in a RESTful service may include URLs.  Therefore, if the response to a request is a set of resources, then the URL of each of  532 Chapter 18 ■ Service-oriented software engineering  Service  Restful API  requestor 1  Resource  R  SOAP-based  Service  Figure 18.7 RESTful  API  requestor 2  and SOAP-based APIs  these services may be included. The requesting service may then process the  requests in its own way. Therefore, a request for weather information given a place  name that is not unique may return the URLs of all of the places that match the request.  For example:  http://weather-info-example.net/temperatures/edinburgh-scotland  http://weather-info-example.net/temperatures/edinburgh-australia  http://weather-info-example.net/temperatures/edinburgh-maryland  A fundamental design principle for RESTful services is that they should be stateless. That is, in an interaction session, the resource itself should not include any state information, such as the time of the last request. Instead, all necessary state information should be returned to the requestor. If state information is required in later requests, it should be returned to the server by the requestor.  RESTful services have become more widely used over the past few years because  of the widespread use of mobile devices. These devices have limited processing  capabilities, so the lower overhead of RESTful services allows better system performance. They are also easy to use with existing websites—implementing a RESTful  API for a website is usually fairly straightforward.  However, there are problems with the RESTful approach:  1. When a service has a complex interface and is not a simple resource, it can be  difficult to design a set of RESTful services to represent this interface.  2. There are no standards for RESTful interface description, so service users must  rely on informal documentation to understand the interface.  3. When you use RESTful services, you have to implement your own infrastructure for monitoring and managing the quality of service and the service reliability. SOAP-based services have additional infrastructure support standards such  as WS-Reliability and WS-Transactions.  Pautasso et al. (Pautasso, Zimmermann, and Leymann 2008) discuss when  RESTful and SOAP-based should be used. However, it is often possible to provide  both SOAP-based and RESTful interfaces to the same service or resource (Figure  18.7). This dual approach is now common for cloud services from providers such as  Microsoft, Google, and Amazon. Service clients can then choose the service access  method that is best suited to their applications.    18.3 ■ Service engineering 533  Service  Service  candidate  Service design  implementation  identification  and deployment  Service  Service interface  Validated and  requirements  specification  deployed service  Figure 18.8 The service  engineering process

### 18.3 Service engineering:

Service engineering is the process of developing services for reuse in service-oriented applications. It has much in common with component engineering. Service engineers have to ensure that the service represents a reusable abstraction that could be useful in different systems. They must design and develop generally useful  functionality associated with that abstraction and ensure that the service is robust and reliable. They have to document the service so that it can be discovered and  understood by potential users.  As shown in Figure 18.8, there are three logical stages in the service engineering  process:  1. Service candidate identification, where you identify possible services that might be implemented and define the service requirements.  2. Service design, where you design the logical service interface and its implementation interfaces (SOAP-based and/or RESTful).  3. Service implementation and deployment, where you implement and test the service and make it available for use.  As I discussed in Chapter 16, the development of a reusable component may  start with an existing component that has already been implemented and used in  an application. The same is true for services—the starting point for this process  will often be an existing service or a component that is to be converted to a service. In this situation, the design process involves generalizing the existing component so that application-specific features are removed. Implementation means  adapting the component by adding service interfaces and implementing the  required generalizations.    18.3.1 Service candidate identification  The basic idea of service-oriented computing is that services should support business processes. As every organization has a wide range of processes, many possible  services may be implemented. Service candidate identification therefore involves  534 Chapter 18 ■ Service-oriented software engineering  Utility  Business  Coordination  Task  Currency converter  Validate claim form  Process expense claim  Employee locator  Check credit rating  Pay external supplier  Entity  Document translator  Expenses form  Web form to XML converter  Student application form  Figure 18.9 Service  understanding and analyzing the organization’s business processes to decide which  classification  reusable services could be implemented to support these processes.  Erl (Erl 2005) suggests that there are three fundamental types of service:  1. Utility services. These services implement some general functionality that may be used by different business processes. An example of a utility service is a currency conversion service that can be accessed to compute the conversion of one currency (e.g., dollars) to another (e.g., euros).  2. Business services. These services are associated with a specific business function. An example of a business function in a university would be the registration  of students for a course.  3. Coordination or process services. These services support a more general business process that usually involves different actors and activities. An example of  a coordination service in a company is an ordering service that allows orders to  be placed with suppliers, goods accepted, and payments made.  Erl also suggests that services can be thought of as task-oriented or entity-oriented. Task-oriented services are associated with some activity, whereas entity-oriented services are associated with a system resource. The resource is a business  entity such as a job application form. Figure 18.9 shows examples of services that  are task-oriented or entity-oriented. Utility or business services may be entity-oriented or task-oriented. Coordination services are always task-oriented.  Your goal in service candidate identification should be to identify services that  are logically coherent, independent, and reusable. Erl’s classification is helpful in this respect, as it suggests how to discover reusable services by looking at business entities as resources and business activities. However, identifying service candidates is sometimes difficult because you have to envisage how the services could be used.  You have to think of possible candidates and then ask a series of questions about  them to see if they are likely to be useful services. Possible questions that you might ask to identify potentially reusable services are:  1. For an entity-oriented service, is the service associated with a single logical  resource that is used in different business processes? What operations are normally performed on that entity that must be supported? Do these fit with the  RESTful service operations PUT, CREATE, POST, and DELETE?  2. For a task-oriented service, is the task one that is carried out by different people in the organization? Will they be willing to accept the inevitable standardization    18.3 ■ Service engineering 535  that occurs when a single support service is provided? Can this fit into the  RESTful model, or should it be redesigned as an entity-oriented service.  3. Is the service independent? That is, to what extent does it rely on the availability of other services?  4. Does the service have to maintain state? If state information is required, this  must either be maintained in a database or passed as a parameter to the service.  Using a database affects service reusability as there is a dependency between the  service and the required database. In general, services where the state is passed  to the service are easier to reuse, as no database binding is required.  5. Might this service be used by external clients? For example, an entity-oriented  service associated with a catalog could be made available to both internal and  external users.  6. Are different users of the service likely to have different nonfunctional requirements? If they do, then more than one version of a service should perhaps be  implemented.  The answers to these questions help you select and refine abstractions that can be  implemented as services. However, there is no formulaic way of deciding which are  the best services. You need to use your experience and business knowledge to decide  on what are the most appropriate services.  The output of the service selection process is a set of identified services and associated requirements for these services. The functional service requirements should  define what the service should do. The nonfunctional requirements should define  the security, performance, and availability requirements of the service.  To help you understand the process of service candidate identification and  implementation, consider the following example:  A company, which sells computer equipment, has arranged special prices for  approved configurations for some large customers. To facilitate automated  ordering, the company wishes to produce a catalog service that will allow  customers to select the equipment that they need. Unlike a consumer catalog,  orders are not placed directly through a catalog interface. Instead, goods are  ordered through the web-based procurement system of each company that  accesses the catalog as a web service. The reason for this is that large compa-  nies usually have their own budgeting and approval procedures for orders that  must be followed when an order is placed.  The catalog service is an example of an entity-oriented service, where the underlying resource is the catalog. The functional catalog service requirements are as follows: 1. A specific version of the catalog shall be provided for each user company. This shall include the approved configurations and equipment that may be ordered by  536 Chapter 18 ■ Service-oriented software engineering  employees of the customer company and the equipment prices that have been  agreed to with that company.  2. The catalog shall allow a customer employee to download a version of the catalog for offline browsing.  3. The catalog shall allow users to compare the specifications and prices of up to  six catalog items.  4. The catalog shall provide browsing and search facilities for users.  5. Users of the catalog shall be able to discover the predicted delivery date for a given number of specific catalog items.  6. Users of the catalog shall be able to place “virtual orders” where the items  required will be reserved for them for 48 hours. Virtual orders must be confirmed by a real order placed by a procurement system. The real order must be  received within 48 hours of the virtual order.  In addition to these functional requirements, the catalog has a number of nonfunctional requirements:  1. Access to the catalog service shall be restricted to employees of accredited  organizations.  2. The prices and configurations offered to each customer shall be confidential,  and access to these shall only be provided to employees of that customer.  3. The catalog shall be available without disruption of service from 0700 GMT to  1100 GMT.  4. The catalog service shall be able to process up to 100 requests per second peak load.  There is no nonfunctional requirement related to the response time of the catalog  service. This depends on the size of the catalog and the expected number of simultaneous users. As this is not a time-critical service, there is no need to specify the required performance at this stage.    18.3.2 Service interface design  Once you have identified candidate services, the next stage in the service engineering process is to design the service interfaces. This involves defining the operations associated with the service and their parameters. If SOAP-based services are used,  you have to design the input and output messages. If RESTful services are used, you  have to think about the resources required and how the standard operations should be used to implement the service operations.  The starting point for service interface design is abstract interface design. where  you identify the entities and the operations associated with the service, their inputs and    18.3 ■ Service engineering 537  Operation  Description  MakeCatalog  Creates a version of the catalog tailored for a specific customer. Includes an  optional parameter to create a downloadable PDF version of the catalog.  Lookup  Displays all of the data associated with a specified catalog item.  Search  Takes a logical expression and searches the catalog according to that  expression. It displays a list of all items that match the search expression.  Compare  Provides a comparison of up to six characteristics (e.g., price, dimensions,  processor speed, etc.) of up to four catalog items.  CheckDelivery  Returns the predicted delivery date for an item if ordered that day.  MakeVirtualOrder  Reserves the number of items to be ordered by a customer and provides item  information for the customer’s own procurement system.  Figure 18.10 Catalog  operations  outputs, and the exceptions associated with these operations. You then need to think about how this abstract interface is realized as SOAP-based or RESTful services.  If you choose a SOAP-based approach, you have to design the structure of the XML  messages that are sent and received by the service. The operations and messages are the basis of an interface description written in WSDL. If you choose a RESTful approach, you have to design how the service operations map onto the RESTful operations.  Abstract interface design starts with the service requirements and defines the  operation names and parameters. At this stage, you should also define the exceptions that may arise when a service operation is invoked. Figure 18.10 shows the catalog  operations that implement the requirements. There is no need for these to be specified in detail; you add detail at the next stage of the design process.  Once you have established an informal description of what the service should do,  the next stage is to add more detail of the service inputs and outputs. I have shown this for the catalog service in Figure 18.11, which extends the functional description in Figure 18.10.  Defining exceptions and how these exceptions can be communicated to service  users is particularly important. Service engineers do not know how their services  will be used. It is usually unwise to make assumptions that service users will have  completely understood the service specification. Input messages may be incorrect,  so you should define exceptions that report incorrect inputs to the service client. It is generally good practice in reusable component development to leave all exception  handling to the user of the component. Service developers should not impose their  views on how exceptions should be handled.  In some cases, a textual description of the operations and their inputs and outputs  is all that is required. The detailed realization of the service is left as an implementation decision. Sometimes, however, you need to have a more detailed design, and a  detailed interface description can be specified in a graphical notation such as the  UML or in a readable description format such as JSON. Figure 18.12, which  describes the inputs and outputs for the getDelivery operation, shows how you can  use the UML to describe the interface in detail.  538 Chapter 18 ■ Service-oriented software engineering  Operation  Inputs  Outputs  Exceptions  MakeCatalog  mcIn  mcOut  mcFault  Company id  URL of the catalog for  Invalid company id  PDF-flag  that company  Lookup  lookIn  lookOut  lookFault  Catalog URL  URL of page with the  Invalid catalog  Catalog number  item information  number  Search  searchIn  searchOut  searchFault  Catalog URL  URL of web page with  Badly formed search  Search string  search results  string  Compare  compIn  compOut  compFault  Catalog URL  URL of page showing  Invalid company id  Entry attribute (up to 6)  comparison table  Invalid catalog number  Catalog number (up to 4)  Unknown attribute  CheckDelivery  cdIn  cdOut  cdFault  Company id  Expected delivery  Invalid company id  Catalog number  date  No availability  Number of items required  Zero items requested  MakeVirtualOrder  voIn  voOut  voFault  Company id  Catalog number  Invalid company id  Catalog number  Number of items  Invalid catalog  Number of items required  required  number  Predicted delivery date  Zero items requested  Unit price estimate  Total price estimate  Figure 18.11 Catalog  interface design  cdIn  size (cID) = 6  cID: string  size (catNum) = 10  catNum: string  numItems > 0  numItems: integer  cdOut  catNum: string  size (catNum) = 10  delivDate: date  delivDate > Today  Invalid company id  cdFault  errCode=1  Invalid catalog number  errCode: integer  errCode = 2  No availability  Figure 18.12 UML  errCode = 3  Zero items requested  definition of input and  errCode = 4  output messages    18.3 ■ Service engineering 539  Notice how I have added detail to the description by annotating the UML diagram  with constraints. These details define the length of the strings representing the company and the catalog item, and specify that the number of items must be greater than zero and that delivery must be after the current date. The annotations also show which error codes are associated with each possible fault.  The catalog service is an example of a practical service, which illustrates that it is not always straightforward whether to choose a RESTful or a SOAP-based approach  to service implementation. As an entity-based service, the catalog can be represented as a resource, which suggests that a RESTful model is the right one to use. However, operations on the catalog are not simple GET operations, and you need to maintain some state in an interaction session with the catalog. This suggests the use of a SOAP-based approach. Such dilemmas are common in service engineering, and usually  local circumstances (e.g., availability of expertise) are a major factor in the decision of which approach to use.  To implement a set of RESTful services, you have to decide on the set of resources  that will be used to represent the catalog and how the fundamental GET, POST, and  PUT operations will operate on these resources. Some of these design decisions are  straightforward:  1. There should be a resource representing a company-specific catalog. This should  have a URL of the form <base catalog>/<company name> and should be created using a POST operation.  2. Each catalog item should have its own URL of the form <base catalog>/<company name>/<item identifier>.  3. You use the GET operation to retrieve items. Lookup is implemented by using the  URL of an item in a catalog as the GET parameter. Search is implemented by using  GET with the company catalog as the URL and the search string as a query parameter.  This GET operation returns a list of URLs of the items matching the search.  However, the Compare, CheckDelivery, and MakeVirtualOrder operations are  more complex:      1. The   Compare operation can be implemented as a sequence of GET operations to  retrieve the individual items, followed by a POST operation to create the comparison table and a final GET operation to return this to the user.      2. The   CheckDelivery and MakeVirtualOrder operations require an additional  resource, representing a virtual order. A POST operation is used to create this  resource with the number of items required. The company id is used to automatically fill in the order form, and the delivery date is calculated. The resource  can then be retrieved using a GET operation.  You need to think carefully about how exceptions are mapped onto the standard  http response codes such as a 404 code, meaning that a URL cannot be retrieved.  I don’t have space to go into this issue here, but it adds a further level of complexity to the service interface design.  540 Chapter 18 ■ Service-oriented software engineering  Legacy system services  Legacy systems are old software systems that are used by an organization. It may not be cost-effective to rewrite or replace these systems, and many organizations would like to use them in conjunction with more modern systems. One of the most important uses of services is to implement “wrappers” for legacy systems that provide access to a system’s functions and data. These systems can then be accessed over the web and integrated with other applications.  http://software-engineering-book.com/web/legacy-services  For SOAP-based services, the realization process, in this case, is simpler as the  logical interface design can be translated automatically into WSDL. Most programming environments that support service-oriented development (e.g., the ECLIPSE  environment) include tools that can translate a logical interface description into its corresponding WSDL representation.    18.3.3 Service implementation and deployment  Once you have identified candidate services and designed their interfaces, the final stage of the service engineering process is service implementation. This implementation may involve programming the service using a language such as Java or C#.  Both of these languages include libraries with extensive support for developing  SOAP-based and RESTful services.  Alternatively, you can implement services by creating service interfaces to existing components or legacy systems. Software assets that have already proved to be useful  can therefore be made available for reuse. In the case of legacy systems, it may mean that the system functionality can be accessed by new applications. You can also develop new services by defining compositions of existing services, as I explain in Section 18.4.  Once a service has been implemented, it then has to be tested before it is deployed.  This involves examining and partitioning the service inputs (as explained in Chapter 8), creating input messages that reflect these input combinations, and then checking that the outputs are expected. You should always try to generate exceptions during the test to check that the service can cope with invalid inputs. For SOAP-based services, testing tools are available that allow services to be examined and tested, and that generate tests from a WSDL specification. However, these tools can only test the conformity of the service interface to the WSDL. They cannot test the service’s functional behavior.  Service deployment, the final stage of the process, involves making the service  available for use on a web server. Most server software makes this operation straightforward. You install the file containing the executable service in a specific directory.  It then automatically becomes available for use.  If the service is intended to be available within a large organization or as a publicly available service, you then have to provide documentation for external service users. Potential users can then decide if the service is likely to meet their needs and    18.4 ■ Service composition 541  if they can trust you, as a service provider, to deliver the service reliably and securely.  Information that you may include in a service description might be:  1. Information about your business, contact details, and so on. This is important  for trust reasons. External users of a service have to be confident that it will not behave maliciously. Information about the service provider allows users to  check their credentials with business information agencies.  2. An informal description of the functionality provided by the service. This helps potential users to decide if the service is what they want.  3. A description of how to use the service. For simple services, this can be an  informal textual description that explains the input and output parameters. For  more complex SOAP-based services, the WSDL description may be published.  4. Subscription information that allows users to register for information about  updates to the service.  A general difficulty with service specifications is that the functional behavior of  the service is usually specified informally, as a natural language description. Natural language descriptions are easy to read, but they are subject to misinterpretation. To address this problem, there has been extensive research on using ontologies and ontology languages for specifying service semantics by marking up the service with  ontology information (W3C 2012). However, ontology-based specification is complex and not widely understood. Consequently, it has not been widely used.

### 18.4 Service composition:

The underlying principle of service-oriented software engineering is that you compose and configure services to create new, composite services. These may be integrated  with a user interface implemented in a browser to create a web application, or they  may be used as components in some other service composition. The services involved  in the composition may be specially developed for the application, business services developed within a company, or services from an external provider. Both RESTful and  SOAP-based services can be composed to create services with extended functionality.  Many companies have converted their enterprise applications into service-oriented  systems, where the basic application building block is a service rather than a component. This allows for widespread reuse within the company. We are now seeing the  emergence of interorganizational applications between trusted suppliers, who use  each other’s services. The final realization of the long-term vision of service-oriented systems will rely on the development of a “services market,” where services are  bought from trusted external suppliers.  Service composition may be used to integrate separate business processes to provide an integrated process offering more extensive functionality. Say an airline wishes to develop a travel aggregation service that provides a complete vacation package for  542 Chapter 18 ■ Service-oriented software engineering  Book      Book   Arrange   Browse      Book   flights   hotel  car or taxi  attractions  attractions  Dates/preferences  Arrival/departure  Figure 18.13 Vacation  dates/times  package workflow  Hotel location  travelers. In addition to booking their flights, travelers can also book hotels in their preferred location, arrange car rental or book a taxi from the airport, browse a travel guide, and make reservations to visit local attractions. To create this application, the airline composes its own booking service with services offered by a hotel booking agency, rental car and taxi companies, and reservation services offered by owners of local attractions.  The end result is a single service that integrates the services from different providers.  You can think of this process as a sequence of separate steps, as shown in Figure  18.13. Information is passed from one step to the next. For example, the rental car  company is informed of the time that the flight is scheduled to arrive. The sequence of steps is called a workflow—a set of activities ordered in time, with each activity carrying out some part of the work. A workflow is a model of a business process; that is, it sets out the steps involved in reaching a particular goal that is important for a business.  In this case, the business process is the vacation booking service, offered by the airline.  Workflow is a simple idea, and the above scenario of booking a vacation seems to  be straightforward. In practice, service composition is usually more complex than  this simple model implies. You have to consider the possibility of service failure and include exception management to handle these failures. You also have to take into  account nonstandard demands made by users of the application. For example, say a  traveler was disabled and required a wheelchair to be rented and delivered to the  airport. This would require extra services to be implemented and composed, with  additional steps added to the workflow.  When designing a travel aggregation service, you must be able to cope with situations where the normal execution of one of the services results in an incompatibility with some other service execution. For example, say a flight is booked to leave on  June 1 and to return on June 7. The workflow then proceeds to the hotel booking  stage. However, the resort is hosting a major convention until June 2, so no hotel  rooms are available. The hotel booking service reports this lack of availability. This is not a failure; lack of availability is a common situation.  You therefore have to “undo” the flight booking and pass the information about  lack of availability back to the user. He or she then has to decide whether to change the dates or the resort. In workflow terminology, this is called a compensation action.  Compensation actions are used to undo actions that have already been completed but  that must be changed as a result of later workflow activities.  The process of designing new services by reusing existing services is a process of  software design with reuse (Figure 18.13). Design with reuse inevitably involves  requirements compromises. The “ideal” requirements for the system have to be modified to reflect the services that are actually available, whose costs fall within budget and whose quality of service is acceptable.    18.4 ■ Service composition 543  Formulate  Discover  Select  Refine  Create  outline  Test  services  services  workflow  workflow  workflow  program  service  Workflow  Service list  Service  Workflow  Executable  Deployable  design  specifications  design  workflow  service  Figure 18.14 Service  construction by  I have shown the six key stages in the process of system construction by composi—  composition  tion in Figure 18.14:  1. Formulate outline workflow In this initial stage of service design, you use the requirements for the composite service as a basis for creating an “ideal” service  design. You should create a fairly abstract design at this stage, with the intention of adding details once you know more about available services.  2. Discover services During this stage of the process, you look for existing services to include in the composition. Most service reuse is within enterprises, so  this may involve searching local service catalogs. Alternatively, you may search  the services offered by trusted service providers, such as Oracle and Microsoft.  3. Select possible services From the set of possible service candidates that you have discovered, you then select possible services that can implement workflow  activities. Your selection criteria will obviously include the functionality of the  services offered. They may also include the cost of the services and the quality  of service (responsiveness, availability, etc.) offered.  4. Refine workflow On the basis of information about the services that you have selected, you then refine the workflow. This involves adding detail to the abstract description and perhaps adding or removing workflow activities. You may then repeat the service discovery and selection stages. Once a stable set of services has been chosen and the final workflow design established, you move on to the next stage in the process.  5. Create workflow program During this stage, the abstract workflow design is transformed to an executable program and the service interface is defined. You  can implement workflow programs using a programming language, such as Java  or C#, or by using a workflow language, such as BPMN (explained below). This  stage may also involve the creation of web-based user interfaces to allow the  new service to be accessed from a web browser.  6. Test completed service or application The process of testing the completed, composite service is more complex than component testing in situations where  external services are used. I discuss testing issues in Section 18.4.2.  This process assumes that existing services are available for composition. If you  rely on external information that is not available through a service interface, you  may have to implement these services yourself. This usually involves a “screen  544 Chapter 18 ■ Service-oriented software engineering  scraping” process where your program extracts information from the HTML text of  web pages that are sent to a browser for rendering.    18.4.1 Workflow design and implementation  Workflow design involves analyzing existing or planned business processes to  understand the tasks involved and how these tasks exchange information. You then  define the new business process in a workflow design notation. This sets out the  stages involved in enacting the process and the information that is passed between  the different process stages. However, existing processes may be informal and  dependent on the skills and ability of the people involved. There may be no “normal”  way of working or process definition. In such cases, you have to use your knowledge  of the current process to design a workflow that achieves the same goals.  Workflows represent business process models. They are graphical models that are  written using UML activity diagrams or BPMN, the Business Process Modeling Notation  (White and Miers 2008; OMG 2011). I use BPMN for the examples in this chapter. If  you use SOAP-based services, it is possible to convert BPMN workflows automatically  into WS-BPEL, an XML-based workflow language. This is conformant with other web  service standards such as SOAP and WSDL. RESTful services may be composed within  a program in a standard programming language such as Java. Alternatively, a composition language used for service mashups may be used (Rosenberg et al. 2008).  Figure 18.15 is an example of a simple BPMN model of part of the vacation package scenario, shown in Figure 18.14. The model shows a simplified workflow for  hotel booking and assumes the existence of a Hotels service with associated operations called GetRequirements, CheckAvailability, ReserveRooms, NoAvailability,  ConfirmReservation, and CancelReservation. The process involves getting requirements from the customer, checking room availability, and then, if rooms are available, making a booking for the required dates.  This model introduces some of the core concepts of BPMN that are used to create  workflow models:  1. Rectangles with rounded corners represent activities. An activity can be executed by a human or by an automated service.  2. Circles represent discrete events. An event is something that happens during a  business process. A simple circle is used to represent a starting event and a  darker circle to represent an end event. A double circle (not shown) is used to  represent an intermediate event. Events can be clock events, thus allowing workflows to be executed periodically or timed out.  3. A diamond is used to represent a gateway. A gateway is a stage in the process  where some choice is made. For example, in Figure 18.15, a choice is made on  the basis of whether or not rooms are available.  4. A solid arrow shows the sequence of activities; a dashed arrow represents message flow between activities. In Figure 18.15, these messages are passed  between the hotel booking service and the customer.    18.4 ■ Service composition 545  Retry  Cancel  No rooms  Hotels.  NoAvailability  Hotels.  Hotels.  GetRequirements  CheckAvailability  Hotels.  Rooms OK  ReserveRooms  Hotels.  ConfirmReservation  Customer  Figure 18.15 A  fragment of a hotel  These key features are enough to describe most workflows. However, BPMN  booking workflow  includes many additional features that I don’t have space to describe here. These add information to a business process description that allows it to be automatically translated into an executable service.  Figure 18.15 shows a process that is enacted in a single organization, the company that provides a booking service. However, the key benefit of a service-oriented approach is that it supports interorganizational computing. This means that a computation involves processes and services in different companies. This process is represented in BPMN by developing separate workflows for each of the organizations involved with interactions between them.  To illustrate multiple workflow processes, I use a different example, drawn  from high-performance computing, where hardware is offered as a service.  Services are created to provide access to high-performance computers to a geographically distributed user community. In this example, a vector-processing computer (a machine that can carry out parallel computations on arrays of values) is  offered as a service (VectorProcService) by a research laboratory. This is accessed  through another service called SetupComputation. These services and their  interactions are shown in Figure 18.16.  In this example, the workflow for the SetupComputation service asks for access  to a vector processor and, if a processor is available, establishes the computation  required and downloads data to the processing service. Once the computation is  complete, the results are stored on the local computer. The workflow for  VectorProcService includes the following steps:  Check if a processor is available  Allocate resources for the computation  Initialize the system  546 Chapter 18 ■ Service-oriented software engineering  Restart  No processor  Fail  Request  Set up job  Download  Start  processor  parameters  data  computation  OK  OK  SetupComputation  Store  Report  results  completion  Check  Allocate  Initialize  Compute  Availability  resources  Return  results  VectorProcService  Figure 18.16 Interacting Carry out the computation  workflows  Return the results to the client service  In BPMN terms, the workflow for each organization is represented in a separate  pool. It is shown graphically by enclosing the workflow for each participant in the  process in a rectangle, with the name written vertically on the left edge. The workflows in each pool are coordinated by exchanging messages. In situations where  different parts of an organization are involved in a workflow, pools are divided into named “lanes.” Each lane shows the activities in that part of the organization.  Once a business process model has been designed, it has to be refined depending  on the services that have been discovered. As I suggested in the discussion of Figure 18.14, the model may go through a number of iterations until a design that allows the maximum possible reuse of available services has been created.  Once the final design is available, you can then develop the final service-oriented  system. This involves implementing services that are not available for reuse and converting the workflow model into an executable program. As services are implementation-language independent, new services can be written in any language. The workflow model may be automatically processed to create an executable WS-BPEL model if  SOAP-based services are used. Alternatively, if RESTful services are used, the workflow may be manually programmed, with the model acting as a program specification.    18.4.2 Testing service compositions  Testing is important in all system development processes as it demonstrates that a  system meets its functional and nonfunctional requirements and detects defects that    18.4 ■ Service composition 547  have been introduced during the development process. Many testing techniques,  such as program inspections and coverage testing, rely on analysis of the software  source code. However, if you use services from an external provider, you will not  have access to the source code of the service implementations. You cannot therefore  use “white box” testing techniques that rely on the source code of the system.  As well as problems of understanding the implementation of the service, testers  may also face further difficulties when testing service compositions:  1. External services are under the control of the service provider rather than the  user of the service. The service provider may withdraw these services at any time  or may make changes to them, which invalidates any previous application testing. These problems are handled in software components by maintaining different versions of the component, but service versions are not normally supported.  2. If services are dynamically bound, an application may not always use the same  service each time that it is executed. Therefore, tests may be successful when an  application is bound to a particular service, but it cannot be guaranteed that that  service will be used during an actual execution of the system. This problem has  been one reason why dynamic binding has not been widely used.  3. The nonfunctional behavior of a service is not simply dependent on how it is used by the application that is being tested. A service may perform well during testing  because it is not operating under a heavy load. In practice, the observed service  behavior may be different because of the demands made by other service users.  4. The payment model for services could make service testing very expensive.  There are different possible payment models: Some services may be freely  available, some may be paid for by subscription, and others may be paid for on  a per-use basis. If services are free, then the service provider will not wish them  to be loaded by applications being tested; if a subscription is required, then a  service user may be reluctant to enter into a subscription agreement before testing the service. Similarly, if the usage is based on payment for each use, service  users may find the cost of testing to be prohibitive.  5. I have discussed the notion of compensation actions that are invoked when an  exception occurs and previous commitments that have been made (such as a  flight reservation) have to be revoked. There is a problem in testing such actions  as they may depend on the failure of other services. Simulating the failure of  these services during the testing process is usually difficult.  These problems are particularly acute when external services are used. They are  less serious when services are used within the same company or where cooperating  companies trust services offered by their partners. In such cases, source code may  be available to guide the testing process, and payment for services is unlikely to  be a problem. Resolving these testing problems and producing guidelines, tools,  and techniques for testing service-oriented applications remains an important  research issue.  548  548 Chapter 18 ■ Service-oriented  vice-oriented software  softwar engineering  K e y P o i n ts  ■ Service-oriented architecture is an approach to software engineering where reusable, standardized services are the basic building blocks for application systems.  ■ Services may be implemented within a service-oriented architecture using a set of XML-based web service standards. These include standards for service communication, interface definition, and service enactment in workflows.  ■ Alternatively, a RESTful architecture may be used, which is based on resources and standard operations on these resources. A RESTful approach uses the http and https protocols for service communication and maps operations on the standard http verbs POST, GET, PUT, and DELETE.  ■ Services may be classified as utility services that provide a general-purpose functionality, business services that implement part of a business process, or coordination services that coordinate the execution of other services.  ■ The service engineering process involves identifying candidate services for implementation, defining the service interface, and implementing, testing, and deploying the service.  ■ The development of software using services is based on the idea that programs are created by composing and configuring services to create new composite services and systems.  ■ Graphical workflow languages, such as BPMN, may be used to describe a business process and the services used in that process. These languages can describe interactions between the organizations that are involved.